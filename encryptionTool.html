<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enchiridion - Real-Time Encryption Tool</title>
  <style>
    /* Overall Page Styling */
    body {
      background: #000; /* deep black */
      color: #39FF14;  /* neon green */
      font-family: 'Roboto Mono', monospace;
      padding: 20px;
      margin: 0;
      display: flex;
      justify-content: center;
    }
    #encryptionTool {
      max-width: 800px;
      width: 100%;
    }
    h1 {
      font-size: 28px;
      margin-bottom: 20px;
      text-align: center;
      text-shadow: 0 0 5px #39FF14;
    }
    /* Input, textarea, and button styling */
    textarea, input {
      font-size: 16px;
      background-color: #111;
      color: #39FF14;
      border: 1px solid #39FF14;
      border-radius: 4px;
      padding: 8px;
      width: calc(100% - 20px);
      box-sizing: border-box;
    }
    textarea:focus, input:focus {
      outline: none;
      box-shadow: 0 0 5px #39FF14;
    }
    .button-green {
      background-color: #1B5E20;
      color: #FFF;
      border: 1px solid #39FF14;
      border-radius: 4px;
      padding: 8px 12px;
      margin: 5px 2px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .button-green:hover {
      background-color: #2E7D32;
    }
    .section {
      margin-bottom: 20px;
    }
    label {
      margin-right: 10px;
    }
    /* Special styling for readonly output textarea */
    #outputText {
      background-color: #222;
    }
    /* Mode Toggle Styling */
    .mode-toggle label {
      margin-right: 20px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="encryptionTool">
    <h1>Enchiridion - Real-Time Encrypt/Decrypt</h1>

    <!-- Mode Toggle -->
    <div class="section mode-toggle">
      <strong>Mode:</strong>
      <label><input type="radio" name="mode" value="encrypt" checked> Encrypt</label>
      <label><input type="radio" name="mode" value="decrypt"> Decrypt</label>
    </div>

    <!-- Input Section -->
    <div class="section">
      <label for="inputText">Input Text:</label><br>
      <textarea id="inputText" rows="4" placeholder="Type your text here..."></textarea>
      <button id="trimButton" class="button-green">Trim</button>
    </div>

    <!-- Cipher Checkboxes -->
    <div class="section">
      <strong>Ciphers:</strong><br>
      <input type="checkbox" id="caesarCheckbox">
      <label for="caesarCheckbox">Caesar</label>
      <input type="checkbox" id="vigenereCheckbox">
      <label for="vigenereCheckbox">Vigenere</label>
      <input type="checkbox" id="transpositionCheckbox">
      <label for="transpositionCheckbox">Transposition</label>
      <input type="checkbox" id="atbashCheckbox">
      <label for="atbashCheckbox">Atbash</label>
      <input type="checkbox" id="reverseCheckbox">
      <label for="reverseCheckbox">Reverse</label>
      <input type="checkbox" id="beaufortCheckbox">
      <label for="beaufortCheckbox">Beaufort</label>
      <input type="checkbox" id="shuffleCheckbox">
      <label for="shuffleCheckbox">Shuffle</label>
    </div>

    <!-- Key Input Fields -->
    <div class="section">
      <label for="caesarShift">Caesar Shift:</label>
      <input type="number" id="caesarShift" value="3" min="-25" max="25"><br><br>

      <label for="vigenereKey">Vigenere Key:</label>
      <input type="text" id="vigenereKey"><br><br>

      <label for="transpositionKey">Transposition Key:</label>
      <input type="text" id="transpositionKey"><br><br>

      <label for="beaufortKey">Beaufort Key:</label>
      <input type="text" id="beaufortKey"><br><br>

      <label for="shuffleKey">Shuffle Key:</label>
      <input type="text" id="shuffleKey">
    </div>

    <!-- Output Section -->
    <div class="section">
      <label for="outputText">Output:</label><br>
      <textarea id="outputText" rows="4" readonly></textarea>
    </div>

    <!-- Additional Action Buttons -->
    <div class="section">
      <button id="copyButton" class="button-green">Copy Output</button>
      <button id="clearButton" class="button-green">Clear</button>
      <button id="natoButton" class="button-green">NATO Converter</button>
    </div>
  </div>

  <script>
    /* =========================
       Cipher Functions
    ========================== */
    function caesarCipher(text, shift, decrypt) {
      shift = parseInt(shift);
      if (decrypt) shift = -shift;
      let result = '';
      text = text.toUpperCase();
      for (let i = 0; i < text.length; i++) {
        let c = text.charCodeAt(i);
        if (c >= 65 && c <= 90) {
          let shifted = ((c - 65 + shift) % 26);
          if (shifted < 0) shifted += 26;
          result += String.fromCharCode(65 + shifted);
        } else {
          result += text[i];
        }
      }
      return result;
    }

    function vigenereCipher(text, key, decrypt) {
      text = text.toUpperCase();
      key = key.toUpperCase().replace(/[^A-Z]/g, '');
      if (!key) return text;
      let result = '';
      let keyIndex = 0;
      for (let i = 0; i < text.length; i++) {
        let c = text[i];
        if (c >= 'A' && c <= 'Z') {
          let shift = key.charCodeAt(keyIndex % key.length) - 65;
          if (decrypt) shift = -shift;
          let charCode = c.charCodeAt(0) - 65;
          let shifted = (charCode + shift) % 26;
          if (shifted < 0) shifted += 26;
          result += String.fromCharCode(65 + shifted);
          keyIndex++;
        } else {
          result += c;
        }
      }
      return result;
    }

    function atbashCipher(text) {
      let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let reverse = alphabet.split('').reverse().join('');
      text = text.toUpperCase();
      let result = '';
      for (let i = 0; i < text.length; i++) {
        let c = text[i];
        let index = alphabet.indexOf(c);
        if (index !== -1) {
          result += reverse[index];
        } else {
          result += c;
        }
      }
      return result;
    }

    function reverseCipher(text) {
      return text.split('').reverse().join('');
    }

    function transpositionCipher(text, key, decrypt) {
      text = text.toUpperCase().replace(/[^A-Z]/g, '');
      if (!key) return text;
      if (!decrypt) {
        let numCols = key.length;
        let numRows = Math.ceil(text.length / numCols);
        let matrix = [];
        for (let r = 0; r < numRows; r++) {
          matrix[r] = [];
          for (let c = 0; c < numCols; c++) {
            let index = r * numCols + c;
            matrix[r][c] = index < text.length ? text[index] : 'X';
          }
        }
        let order = key.toUpperCase().split('').map((char, index) => ({ char, index }))
          .sort((a, b) => a.char.localeCompare(b.char));
        let result = '';
        order.forEach(o => {
          for (let r = 0; r < numRows; r++) {
            result += matrix[r][o.index];
          }
        });
        return result;
      } else {
        // Decryption stub â€“ could be enhanced as needed
        return text;
      }
    }

    function beaufortCipher(text, key) {
      text = text.toUpperCase();
      key = key.toUpperCase().replace(/[^A-Z]/g, '');
      if (!key) return text;
      let result = '';
      let keyIndex = 0;
      let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let i = 0; i < text.length; i++) {
        let c = text[i];
        if (alphabet.indexOf(c) !== -1) {
          let K = key.charCodeAt(keyIndex % key.length) - 65;
          let C = c.charCodeAt(0) - 65;
          let newPos = (K - C) % 26;
          if (newPos < 0) newPos += 26;
          result += alphabet[newPos];
          keyIndex++;
        } else {
          result += c;
        }
      }
      return result;
    }

    function shuffleCipher(text, key, decrypt) {
      if (!key.trim()) {
        alert("Shuffle Cipher requires a key.");
        return text;
      }
      let arr = text.split('');
      let seed = 0;
      for (let i = 0; i < key.length; i++) {
        seed = (seed * 31 + key.charCodeAt(i)) % 2147483647;
      }
      function random() {
        seed = (seed * 16807) % 2147483647;
        return seed / 2147483647;
      }
      let permutation = arr.map((_, i) => i);
      for (let i = permutation.length - 1; i > 0; i--) {
        let j = Math.floor(random() * (i + 1));
        [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
      }
      if (decrypt) {
        let inverse = [];
        for (let i = 0; i < permutation.length; i++) {
          inverse[permutation[i]] = i;
        }
        permutation = inverse;
      }
      let shuffled = [];
      for (let i = 0; i < permutation.length; i++) {
        shuffled[i] = arr[permutation[i]];
      }
      return shuffled.join('');
    }

    function processCiphers(text, decrypt) {
      let result = text;
      let order = [];
      if (document.getElementById('caesarCheckbox').checked) order.push('Caesar');
      if (document.getElementById('vigenereCheckbox').checked) order.push('Vigenere');
      if (document.getElementById('transpositionCheckbox').checked) order.push('Transposition');
      if (document.getElementById('atbashCheckbox').checked) order.push('Atbash');
      if (document.getElementById('reverseCheckbox').checked) order.push('Reverse');
      if (document.getElementById('beaufortCheckbox').checked) order.push('Beaufort');
      if (document.getElementById('shuffleCheckbox').checked) order.push('Shuffle');

      if (decrypt) order = order.reverse();

      order.forEach(cipher => {
        switch (cipher) {
          case 'Caesar':
            let shift = document.getElementById('caesarShift').value;
            result = caesarCipher(result, shift, decrypt);
            break;
          case 'Vigenere':
            let vkey = document.getElementById('vigenereKey').value;
            result = vigenereCipher(result, vkey, decrypt);
            break;
          case 'Transposition':
            let tkey = document.getElementById('transpositionKey').value;
            result = transpositionCipher(result, tkey, decrypt);
            break;
          case 'Atbash':
            result = atbashCipher(result);
            break;
          case 'Reverse':
            result = reverseCipher(result);
            break;
          case 'Beaufort':
            let bkey = document.getElementById('beaufortKey').value;
            result = beaufortCipher(result, bkey);
            break;
          case 'Shuffle':
            let skey = document.getElementById('shuffleKey').value;
            result = shuffleCipher(result, skey, decrypt);
            break;
        }
      });
      return result;
    }

    /* =========================
       Event Listeners & Real-Time Processing
    ========================== */
    // Real-time processing as text is typed
    document.getElementById('inputText').addEventListener('input', () => {
      const mode = document.querySelector('input[name="mode"]:checked').value;
      const isDecrypt = (mode === 'decrypt');
      const text = document.getElementById('inputText').value;
      try {
        const processed = processCiphers(text, isDecrypt);
        document.getElementById('outputText').value = processed;
      } catch(e) {
        document.getElementById('outputText').value = "Error: " + e.message;
      }
    });

    // Trim Button
    document.getElementById('trimButton').addEventListener('click', () => {
      let input = document.getElementById('inputText').value;
      if (input.length >= 2) {
        document.getElementById('inputText').value = input.substring(1, input.length - 1);
        // Trigger update after trim
        document.getElementById('inputText').dispatchEvent(new Event('input'));
      } else {
        alert("Input too short to trim.");
      }
    });

    // Copy Output Button
    document.getElementById('copyButton').addEventListener('click', () => {
      let output = document.getElementById('outputText').value;
      if (output) {
        navigator.clipboard.writeText(output);
      }
    });

    // Clear Button
    document.getElementById('clearButton').addEventListener('click', () => {
      document.getElementById('inputText').value = '';
      document.getElementById('outputText').value = '';
    });

    // NATO Converter Button
    document.getElementById('natoButton').addEventListener('click', () => {
      const natoMapping = {
        'A': 'Alpha', 'B': 'Bravo', 'C': 'Charlie', 'D': 'Delta',
        'E': 'Echo', 'F': 'Foxtrot', 'G': 'Golf', 'H': 'Hotel',
        'I': 'India', 'J': 'Juliet', 'K': 'Kilo', 'L': 'Lima',
        'M': 'Mike', 'N': 'November', 'O': 'Oscar', 'P': 'Papa',
        'Q': 'Quebec', 'R': 'Romeo', 'S': 'Sierra', 'T': 'Tango',
        'U': 'Uniform', 'V': 'Victor', 'W': 'Whiskey', 'X': 'X-ray',
        'Y': 'Yankee', 'Z': 'Zulu'
      };
      let input = document.getElementById('inputText').value;
      if (!input.trim()) {
        alert("Please enter text to convert.");
        return;
      }
      let outputLetters = [];
      for (let char of input.toUpperCase()) {
        if (natoMapping[char]) {
          outputLetters.push(natoMapping[char]);
        } else {
          outputLetters.push(char);
        }
      }
      document.getElementById('outputText').value = outputLetters.join('-');
    });
  </script>
</body>
</html>
